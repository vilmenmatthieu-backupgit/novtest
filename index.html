<script>
  const video = document.getElementById('videoFeed');
  const canvas = document.getElementById('cameraCanvas');
  const ctx = canvas.getContext('2d', { willReadFrequently: true });
  const feedback = document.getElementById('feedback');
  const enableCamBtn = document.getElementById('enableCam');
  const mainButton = document.getElementById('mainButton');
  const confirmContainer = document.getElementById('confirmContainer');
  const retakeButton = document.getElementById('retakeButton');
  const confirmButton = document.getElementById('confirmButton');
  const aiOutputContainer = document.getElementById('aiOutputContainer');
  const aiDescriptionContainer = document.getElementById('aiDescription');
  const aiPriceContainer = document.getElementById('aiPriceSuggestion');
  const downloadButton = document.getElementById('downloadButton');
  const framingGuideElement = document.getElementById('framingGuide');

  let finalImageDataUrl = null;
  let rafId = null;

  // --- États UI ---
  const AppState = { SCANNING: 'scanning', CONFIRMING: 'confirming', GENERATING: 'generating', DONE: 'done' };
  let currentAppState = AppState.SCANNING;

  // --- ZOOM state ---
  let track = null;
  let zoomCaps = null;          // capacités matérielles (si dispo)
  let hasHardwareZoom = false;  // indicateur
  let hwZoom = 1;               // zoom matériel courant
  let hwZoomMin = 1;
  let hwZoomMax = 1;

  let swScale = 1;              // fallback: zoom logiciel (canvas)
  const SW_MIN = 1;
  const SW_MAX = 4;             // x4 suffit dans la plupart des cas

  // pinch state
  let pinchStartDist = null;
  let pinchStartZoom = null;    // (hwZoom ou swScale selon le mode)

  document.addEventListener('gesturestart', e => e.preventDefault()); // iOS: éviter le zoom de page
  document.addEventListener('gesturechange', e => e.preventDefault());
  document.addEventListener('gestureend', e => e.preventDefault());

  enableCamBtn.addEventListener('click', async () => {
    enableCamBtn.disabled = true;
    await setupCamera();
  });

  async function setupCamera() {
    feedback.textContent = "Initialisation de la caméra...";
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: { ideal: 'environment' } }, audio: false });
      startStream(stream);
      enableCamBtn.style.display = 'none';
    } catch (e1) {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
        startStream(stream);
        enableCamBtn.style.display = 'none';
      } catch (e2) {
        console.error("Erreur d'accès à la caméra:", e2);
        feedback.textContent = e2.name === 'NotAllowedError' ? "Accès à la caméra refusé."
          : e2.name === 'NotFoundError' ? "Aucune caméra détectée."
          : "Impossible d'accéder à la caméra.";
        mainButton.disabled = true;
        enableCamBtn.disabled = false;
      }
    }
  }

  function startStream(stream) {
    video.srcObject = stream;
    track = stream.getVideoTracks()[0];
    // capacités de zoom matériel
    try {
      zoomCaps = track.getCapabilities?.();
      if (zoomCaps && 'zoom' in zoomCaps) {
        hasHardwareZoom = true;
        hwZoomMin = zoomCaps.zoom.min ?? 1;
        hwZoomMax = zoomCaps.zoom.max ?? 1;
        hwZoom = track.getSettings?.().zoom ?? 1;
      }
    } catch { hasHardwareZoom = false; }

    video.onloadedmetadata = () => {
      video.play();
      setCanvasDimensions();
      startRenderLoop();
      feedback.textContent = hasHardwareZoom
        ? "Pince pour zoomer (zoom natif)."
        : "Pince pour zoomer (zoom logiciel).";
      attachZoomHandlers();
    };
  }

  function setCanvasDimensions() {
    if (!video.videoWidth) return;
    const ratio = video.videoWidth / video.videoHeight;
    const cssW = canvas.parentElement.offsetWidth;
    const cssH = cssW / ratio;
    const dpr = window.devicePixelRatio || 1;

    canvas.style.width = cssW + 'px';
    canvas.style.height = cssH + 'px';
    canvas.width = Math.round(cssW * dpr);
    canvas.height = Math.round(cssH * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  function startRenderLoop() {
    cancelAnimationFrame(rafId);
    const loop = () => {
      if (currentAppState === AppState.SCANNING) {
        if (hasHardwareZoom) {
          // rendu simple (zoom optique déjà appliqué par le capteur)
          ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        } else {
          // zoom logiciel: on recadre au centre selon swScale
          const vw = video.videoWidth;
          const vh = video.videoHeight;
          const scale = Math.max(SW_MIN, Math.min(SW_MAX, swScale));
          const cropW = Math.round(vw / scale);
          const cropH = Math.round(vh / scale);
          const sx = Math.round((vw - cropW) / 2);
          const sy = Math.round((vh - cropH) / 2);
          ctx.drawImage(video, sx, sy, cropW, cropH, 0, 0, canvas.width, canvas.height);
        }
        updateFramingGuidePosition();
      }
      updateUI();
      rafId = requestAnimationFrame(loop);
    };
    rafId = requestAnimationFrame(loop);
  }

  function stopRenderLoop() { if (rafId) cancelAnimationFrame(rafId); rafId = null; }

  function updateUI() {
    aiOutputContainer.style.display =
      (currentAppState === AppState.GENERATING || currentAppState === AppState.DONE) ? 'block' : 'none';
    mainButton.style.display =
      (currentAppState === AppState.SCANNING || currentAppState === AppState.DONE) ? 'inline-block' : 'none';
    confirmContainer.style.display = currentAppState === AppState.CONFIRMING ? 'block' : 'none';
    downloadButton.style.display = 'none';
    framingGuideElement.style.display = currentAppState === AppState.SCANNING ? 'block' : 'none';

    switch (currentAppState) {
      case AppState.SCANNING:
        mainButton.textContent = "Valider";
        mainButton.disabled = false;
        break;
      case AppState.CONFIRMING:
        feedback.textContent = "Validez-vous cette photo ?";
        break;
      case AppState.GENERATING:
        feedback.innerHTML = "✨ Analyse par l'IA en cours...";
        break;
      case AppState.DONE:
        feedback.textContent = "Description générée !";
        mainButton.textContent = "Recommencer";
        mainButton.disabled = false;
        downloadButton.style.display = 'inline-block';
        break;
    }
  }

  function getFrameRect() {
    return {
      width: canvas.width * 0.5,
      height: canvas.height * 0.8,
      x: (canvas.width * 0.25),
      y: (canvas.height * 0.1)
    };
  }

  function updateFramingGuidePosition() {
    const frameRect = getFrameRect();
    const dpr = window.devicePixelRatio || 1;
    framingGuideElement.style.width  = `${Math.round(frameRect.width / dpr)}px`;
    framingGuideElement.style.height = `${Math.round(frameRect.height / dpr)}px`;
    framingGuideElement.style.top    = `${Math.round(frameRect.y / dpr)}px`;
    framingGuideElement.style.left   = `${Math.round(frameRect.x / dpr)}px`;
  }

  function handleMainButtonClick() {
    if (currentAppState === AppState.SCANNING) {
      currentAppState = AppState.CONFIRMING;
      stopRenderLoop();
      // image figée
      if (hasHardwareZoom) {
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      } else {
        const vw = video.videoWidth, vh = video.videoHeight;
        const scale = Math.max(SW_MIN, Math.min(SW_MAX, swScale));
        const cropW = Math.round(vw / scale);
        const cropH = Math.round(vh / scale);
        const sx = Math.round((vw - cropW) / 2);
        const sy = Math.round((vh - cropH) / 2);
        ctx.drawImage(video, sx, sy, cropW, cropH, 0, 0, canvas.width, canvas.height);
      }
      updateFramingGuidePosition();
      updateUI();
    } else if (currentAppState === AppState.DONE) {
      resetApp();
    }
  }

  // --- Pinch & Wheel Zoom handlers ---
  function distance(t1, t2) { return Math.hypot(t1.pageX - t2.pageX, t1.pageY - t2.pageY); }

  function attachZoomHandlers() {
    // PINCH (mobile)
    canvas.addEventListener('touchstart', e => {
      if (e.touches.length === 2) {
        e.preventDefault();
        pinchStartDist = distance(e.touches[0], e.touches[1]);
        pinchStartZoom = hasHardwareZoom ? hwZoom : swScale;
      }
    }, { passive: false });

    canvas.addEventListener('touchmove', e => {
      if (e.touches.length === 2 && pinchStartDist) {
        e.preventDefault();
        const d = distance(e.touches[0], e.touches[1]);
        const factor = d / pinchStartDist;
        if (hasHardwareZoom) {
          const next = clamp(pinchStartZoom * factor, hwZoomMin, hwZoomMax);
          applyHardwareZoom(next);
        } else {
          swScale = clamp(pinchStartZoom * factor, SW_MIN, SW_MAX);
        }
      }
    }, { passive: false });

    canvas.addEventListener('touchend', () => { if (event.touches.length < 2) pinchStartDist = null; });

    // WHEEL (desktop)
    canvas.addEventListener('wheel', e => {
      // ctrlKey (pinch sur trackpad) ou molette classique
      const dir = e.deltaY > 0 ? -1 : 1; // inverser si besoin
      const step = 0.1 * dir;
      if (hasHardwareZoom) {
        applyHardwareZoom(clamp(hwZoom + step, hwZoomMin, hwZoomMax));
      } else {
        swScale = clamp(swScale + step, SW_MIN, SW_MAX);
      }
      e.preventDefault();
    }, { passive: false });
  }

  function clamp(v, min, max) { return Math.min(max, Math.max(min, v)); }

  function applyHardwareZoom(value) {
    if (!track) return;
    hwZoom = value;
    try {
      track.applyConstraints({ advanced: [{ zoom: hwZoom }] });
    } catch (e) {
      // si applyConstraints échoue, on repasse en zoom logiciel
      hasHardwareZoom = false;
      feedback.textContent = "Zoom matériel indisponible, utilisation du zoom logiciel.";
    }
  }

  // --- Génération IA (inchangé sauf appels réseau) ---
  async function generateDescription() {
    const frameRect = getFrameRect();
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = frameRect.width;
    tempCanvas.height = frameRect.height;
    const tempCtx = tempCanvas.getContext('2d');
    tempCtx.drawImage(
      canvas,
      frameRect.x, frameRect.y, frameRect.width, frameRect.height,
      0, 0, frameRect.width, frameRect.height
    );

    const imageDataUrl = tempCanvas.toDataURL('image/jpeg');
    finalImageDataUrl = imageDataUrl;
    const base64ImageData = imageDataUrl.split(',')[1];

    try {
      const response = await fetch('/api/analyze', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ base64: base64ImageData })
      });
      if (!response.ok) throw new Error('Erreur API');
      const result = await response.json();

      const aiText = result?.candidates?.[0]?.content?.parts?.[0]?.text || '';
      let cleaned = aiText.replace(/```json/gi,'').replace(/```/g,'').trim();
      let desc = "Description non disponible.";
      let prix = "Prix non disponible.";

      try {
        const obj = JSON.parse(cleaned);
        desc = obj.description || desc;
        prix = obj.prix || obj.price || prix;
      } catch { cleaned && (desc = cleaned); }

      aiDescriptionContainer.textContent = `"${desc}"`;
      aiPriceContainer.textContent = `Prix suggéré : ${prix}`;
    } catch (e) {
      console.error(e);
      aiDescriptionContainer.textContent = "Une erreur est survenue. Veuillez réessayer.";
      aiPriceContainer.textContent = "";
    } finally {
      currentAppState = AppState.DONE;
      updateUI();
    }
  }

  function resetApp() {
    currentAppState = AppState.SCANNING;
    aiDescriptionContainer.textContent = '';
    aiPriceContainer.textContent = '';
    finalImageDataUrl = null;
    startRenderLoop();
    feedback.textContent = hasHardwareZoom
      ? "Pince pour zoomer (zoom natif)."
      : "Pince pour zoomer (zoom logiciel).";
  }

  confirmButton.addEventListener('click', async () => {
    if (currentAppState === AppState.CONFIRMING) {
      currentAppState = AppState.GENERATING;
      updateUI();
      await generateDescription();
    }
  });

  retakeButton.addEventListener('click', () => {
    if (currentAppState === AppState.CONFIRMING) {
      currentAppState = AppState.SCANNING;
      startRenderLoop();
      updateUI();
    }
  });

  downloadButton.addEventListener('click', () => {
    if (!finalImageDataUrl) return;
    const link = document.createElement('a');
    link.href = finalImageDataUrl;
    link.download = 'snap-avec-novsuity.jpg';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  });

  mainButton.addEventListener('click', handleMainButtonClick);
  window.addEventListener('resize', () => { if (video.srcObject) setCanvasDimensions(); });
</script>
