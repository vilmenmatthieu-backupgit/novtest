<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Snap avec NovSuity</title>

  <!-- Tailwind via CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://rsms.me/inter/inter.css">

  <style>
    body {
      background-color: #111827;
      color: #F9FAFB;
      font-family: 'Inter', sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      margin: 0;
      overflow: hidden;
    }
    #cameraCanvas {
      max-width: 100%;
      border-radius: 0.75rem;
      box-shadow: 0 10px 15px -3px rgba(0,0,0,.1), 0 4px 6px -2px rgba(0,0,0,.05);
    }
    #videoFeed { display: none; }

    /* Boutons plein largeur sur petits écrans */
    @media (max-width: 420px) {
      #mainButton, #retakeButton, #confirmButton, #downloadButton {
        width: 100%;
      }
    }

    /* Slider basique sans chiffres */
    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      height: 6px;
      background: #374151;
      border-radius: 9999px;
      outline: none;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 22px; height: 22px;
      border-radius: 50%;
      background: #06b6d4;
      border: 2px solid #0e7490;
      box-shadow: 0 2px 6px rgba(0,0,0,.25);
    }
    input[type="range"]::-moz-range-thumb {
      width: 22px; height: 22px;
      border-radius: 50%;
      background: #06b6d4;
      border: 2px solid #0e7490;
      box-shadow: 0 2px 6px rgba(0,0,0,.25);
    }
  </style>
</head>
<body class="bg-gray-900 text-gray-100 flex flex-col justify-center items-center p-4">

  <div class="w-full max-w-2xl text-center">
    <h1 class="text-3xl md:text-4xl font-bold mb-2">Snap avec NovSuity</h1>
    <p id="feedback" class="text-lg text-cyan-400 mb-4 h-8 transition-opacity duration-300">
      Prêt à activer la caméra.
    </p>

    <!-- Bouton requis pour iOS/Safari (geste utilisateur) -->
    <button id="enableCam"
      class="mb-4 px-6 py-2 bg-cyan-600 rounded-lg font-semibold hover:bg-cyan-700">
      Activer la caméra
    </button>

    <div class="relative w-full">
      <canvas id="cameraCanvas" class="bg-gray-800 rounded-xl shadow-lg w-full"></canvas>

      <!-- Cadre pointillé propre en SVG -->
      <svg id="framingGuide" class="absolute top-0 left-0 pointer-events-none"
           width="0" height="0" viewBox="0 0 100 100" preserveAspectRatio="none">
        <rect id="fgRect" x="5" y="5" width="90" height="90" rx="12" ry="12"
              fill="none" stroke="white" stroke-width="6"
              stroke-linecap="round" stroke-dasharray="14 16"/>
      </svg>
    </div>

    <video id="videoFeed" playsinline></video>

    <!-- Slider de zoom (aucun chiffre affiché) -->
    <div class="mt-4 w-full">
      <input id="zoomSlider" type="range" min="1" max="4" step="0.01" value="1" class="w-full">
    </div>

    <!-- Sortie IA -->
    <div id="aiOutputContainer" class="mt-4 text-left p-4 bg-gray-800 rounded-lg" style="display:none;">
      <p id="aiDescription" class="text-lg text-gray-300 italic"></p>
      <p id="aiPriceSuggestion" class="mt-3 text-lg text-cyan-400 font-semibold"></p>
    </div>

    <!-- Boutons avec espace, wrap et touch-friendly -->
    <div class="mt-6 flex flex-wrap gap-4 justify-center">
      <button id="mainButton"
        class="px-8 py-3 bg-cyan-600 text-white font-semibold rounded-lg shadow-md hover:bg-cyan-700 focus:outline-none focus:ring-2 focus:ring-cyan-500 focus:ring-opacity-75 transition-transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed">
        Valider
      </button>

      <div id="confirmContainer" class="hidden flex flex-wrap gap-4 justify-center">
        <button id="retakeButton"
          class="px-8 py-3 bg-gray-600 text-white font-semibold rounded-lg shadow-md hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-75 transition-transform hover:scale-105">
          Reprendre
        </button>
        <button id="confirmButton"
          class="px-8 py-3 bg-cyan-600 text-white font-semibold rounded-lg shadow-md hover:bg-cyan-700 focus:outline-none focus:ring-2 focus:ring-cyan-500 focus:ring-opacity-75 transition-transform hover:scale-105">
          Confirmer
        </button>
      </div>

      <button id="downloadButton"
        class="hidden px-8 py-3 bg-green-600 text-white font-semibold rounded-lg shadow-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-75 transition-transform hover:scale-105">
        Télécharger la photo
      </button>
    </div>
  </div>

  <script>
    const video = document.getElementById('videoFeed');
    const canvas = document.getElementById('cameraCanvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    const feedback = document.getElementById('feedback');
    const enableCamBtn = document.getElementById('enableCam');
    const mainButton = document.getElementById('mainButton');
    const confirmContainer = document.getElementById('confirmContainer');
    const retakeButton = document.getElementById('retakeButton');
    const confirmButton = document.getElementById('confirmButton');
    const aiOutputContainer = document.getElementById('aiOutputContainer');
    const aiDescriptionContainer = document.getElementById('aiDescription');
    const aiPriceContainer = document.getElementById('aiPriceSuggestion');
    const downloadButton = document.getElementById('downloadButton');
    const framingGuideElement = document.getElementById('framingGuide');
    const zoomSlider = document.getElementById('zoomSlider');

    let finalImageDataUrl = null;
    let rafId = null;

    const AppState = { SCANNING:'scanning', CONFIRMING:'confirming', GENERATING:'generating', DONE:'done' };
    let currentAppState = AppState.SCANNING;

    // --- Zoom state ---
    let track = null;
    let hasHardwareZoom = false;
    let hwZoom = 1, hwZoomMin = 1, hwZoomMax = 1;

    let swScale = 1;                 // zoom logiciel (fallback)
    const SW_MIN = 1, SW_MAX = 4;

    // Pinch state
    let pinchStartDist = null;
    let pinchStartZoom = null;

    // Empêche le zoom de page iOS pendant le pinch
    document.addEventListener('gesturestart', e => e.preventDefault());
    document.addEventListener('gesturechange', e => e.preventDefault());
    document.addEventListener('gestureend', e => e.preventDefault());

    enableCamBtn.addEventListener('click', async () => {
      enableCamBtn.disabled = true;
      await setupCamera();
    });

    async function setupCamera() {
      feedback.textContent = "Initialisation de la caméra...";
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: { ideal: 'environment' } }, audio: false });
        startStream(stream);
        enableCamBtn.style.display = 'none';
      } catch (e1) {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
          startStream(stream);
          enableCamBtn.style.display = 'none';
        } catch (e2) {
          console.error("Erreur caméra:", e2);
          feedback.textContent =
            e2.name === 'NotAllowedError' ? "Accès à la caméra refusé." :
            e2.name === 'NotFoundError'  ? "Aucune caméra détectée." :
                                            "Impossible d'accéder à la caméra.";
          mainButton.disabled = true;
          enableCamBtn.disabled = false;
        }
      }
    }

    function startStream(stream) {
      video.srcObject = stream;
      track = stream.getVideoTracks()[0];

      // Détecte le zoom matériel
      try {
        const caps = track.getCapabilities?.();
        if (caps && 'zoom' in caps) {
          hasHardwareZoom = true;
          hwZoomMin = caps.zoom.min ?? 1;
          hwZoomMax = caps.zoom.max ?? 1;
          hwZoom = track.getSettings?.().zoom ?? 1;
        }
      } catch { hasHardwareZoom = false; }

      video.onloadedmetadata = () => {
        video.play();
        setCanvasDimensions();
        startRenderLoop();
        attachZoomHandlers();
        syncSliderFromZoom();
        feedback.textContent = hasHardwareZoom
          ? "Pince ou utilise le slider pour zoomer (zoom natif)."
          : "Pince ou utilise le slider pour zoomer (zoom logiciel).";
      };
    }

    function setCanvasDimensions() {
      if (!video.videoWidth) return;
      const ratio = video.videoWidth / video.videoHeight;
      const cssW = canvas.parentElement.offsetWidth;
      const cssH = cssW / ratio;
      const dpr = window.devicePixelRatio || 1;

      canvas.style.width = cssW + 'px';
      canvas.style.height = cssH + 'px';
      canvas.width = Math.round(cssW * dpr);
      canvas.height = Math.round(cssH * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    function startRenderLoop() {
      cancelAnimationFrame(rafId);
      const loop = () => {
        if (currentAppState === AppState.SCANNING) {
          if (hasHardwareZoom) {
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
          } else {
            // zoom logiciel: recadrage central selon swScale
            const vw = video.videoWidth, vh = video.videoHeight;
            const scale = clamp(swScale, SW_MIN, SW_MAX);
            const cropW = Math.round(vw / scale);
            const cropH = Math.round(vh / scale);
            const sx = Math.round((vw - cropW) / 2);
            const sy = Math.round((vh - cropH) / 2);
            ctx.drawImage(video, sx, sy, cropW, cropH, 0, 0, canvas.width, canvas.height);
          }
          updateFramingGuidePosition();
        }
        updateUI();
        rafId = requestAnimationFrame(loop);
      };
      rafId = requestAnimationFrame(loop);
    }
    function stopRenderLoop() { if (rafId) cancelAnimationFrame(rafId); rafId = null; }

    function updateUI() {
      aiOutputContainer.style.display =
        (currentAppState === AppState.GENERATING || currentAppState === AppState.DONE) ? 'block' : 'none';
      mainButton.style.display =
        (currentAppState === AppState.SCANNING || currentAppState === AppState.DONE) ? 'inline-block' : 'none';
      confirmContainer.style.display = currentAppState === AppState.CONFIRMING ? 'flex' : 'none';
      downloadButton.style.display = 'none';
      framingGuideElement.style.display = currentAppState === AppState.SCANNING ? 'block' : 'none';

      switch (currentAppState) {
        case AppState.SCANNING:
          mainButton.textContent = "Valider";
          mainButton.disabled = false;
          break;
        case AppState.CONFIRMING:
          feedback.textContent = "Validez-vous cette photo ?";
          break;
        case AppState.GENERATING:
          feedback.innerHTML = "✨ Analyse par l'IA en cours...";
          break;
        case AppState.DONE:
          feedback.textContent = "Description générée !";
          mainButton.textContent = "Recommencer";
          mainButton.disabled = false;
          downloadButton.style.display = 'inline-block';
          break;
      }
    }

    function getFrameRect() {
      return {
        width: canvas.width * 0.5,
        height: canvas.height * 0.8,
        x: (canvas.width * 0.25),
        y: (canvas.height * 0.1)
      };
    }

    // Met à l’échelle le SVG (cadre pointillé) correctement en px CSS
    function updateFramingGuidePosition() {
      const frame = getFrameRect();
      const dpr = window.devicePixelRatio || 1;
      const svg = framingGuideElement;
      svg.style.width  = `${Math.round(frame.width  / dpr)}px`;
      svg.style.height = `${Math.round(frame.height / dpr)}px`;
      svg.style.left   = `${Math.round(frame.x      / dpr)}px`;
      svg.style.top    = `${Math.round(frame.y      / dpr)}px`;
    }

    function handleMainButtonClick() {
      if (currentAppState === AppState.SCANNING) {
        currentAppState = AppState.CONFIRMING;
        stopRenderLoop();
        // Figer l'image selon le mode de zoom
        if (hasHardwareZoom) {
          ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        } else {
          const vw = video.videoWidth, vh = video.videoHeight;
          const scale = clamp(swScale, SW_MIN, SW_MAX);
          const cropW = Math.round(vw / scale), cropH = Math.round(vh / scale);
          const sx = Math.round((vw - cropW) / 2), sy = Math.round((vh - cropH) / 2);
          ctx.drawImage(video, sx, sy, cropW, cropH, 0, 0, canvas.width, canvas.height);
        }
        updateFramingGuidePosition();
        updateUI();
      } else if (currentAppState === AppState.DONE) {
        resetApp();
      }
    }

    // --- Pinch & wheel ---
    function distance(t1, t2) { return Math.hypot(t1.pageX - t2.pageX, t1.pageY - t2.pageY); }
    function clamp(v, min, max) { return Math.min(max, Math.max(min, v)); }

    function attachZoomHandlers() {
      // Pinch
      canvas.addEventListener('touchstart', e => {
        if (e.touches.length === 2) {
          e.preventDefault();
          pinchStartDist = distance(e.touches[0], e.touches[1]);
          pinchStartZoom = hasHardwareZoom ? hwZoom : swScale;
        }
      }, { passive: false });

      canvas.addEventListener('touchmove', e => {
        if (e.touches.length === 2 && pinchStartDist) {
          e.preventDefault();
          const d = distance(e.touches[0], e.touches[1]);
          const factor = d / pinchStartDist;
          if (hasHardwareZoom) {
            const next = clamp(pinchStartZoom * factor, hwZoomMin, hwZoomMax);
            applyHardwareZoom(next);
          } else {
            swScale = clamp(pinchStartZoom * factor, SW_MIN, SW_MAX);
            zoomSlider.value = String(swScale);
          }
        }
      }, { passive: false });

      canvas.addEventListener('touchend', e => { if (e.touches.length < 2) pinchStartDist = null; });

      // Molette/trackpad
      canvas.addEventListener('wheel', e => {
        const dir = e.deltaY > 0 ? -1 : 1;
        const step = 0.1 * dir;
        if (hasHardwareZoom) {
          applyHardwareZoom(clamp(hwZoom + step, hwZoomMin, hwZoomMax));
        } else {
          swScale = clamp(swScale + step, SW_MIN, SW_MAX);
          zoomSlider.value = String(swScale);
        }
        e.preventDefault();
      }, { passive: false });

      // Slider (pas d’affichage numérique)
      zoomSlider.addEventListener('input', (e) => {
        const v = parseFloat(e.target.value);
        if (hasHardwareZoom) applyHardwareZoom(v);
        else swScale = clamp(v, SW_MIN, SW_MAX);
      });
    }

    function syncSliderFromZoom() {
      if (hasHardwareZoom) {
        zoomSlider.min = String(hwZoomMin || 1);
        zoomSlider.max = String(hwZoomMax || 4);
        zoomSlider.value = String(hwZoom);
      } else {
        zoomSlider.min = "1";
        zoomSlider.max = "4";
        zoomSlider.value = String(swScale);
      }
    }

    function applyHardwareZoom(value) {
      if (!track) return;
      hwZoom = value;
      try {
        track.applyConstraints({ advanced: [{ zoom: hwZoom }] });
        zoomSlider.value = String(hwZoom);
      } catch (e) {
        // si échec, repasser en logiciel
        hasHardwareZoom = false;
        feedback.textContent = "Zoom matériel indisponible, utilisation du zoom logiciel.";
        syncSliderFromZoom();
      }
    }

    // --- IA ---
    async function generateDescription() {
      const frameRect = getFrameRect();
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = frameRect.width;
      tempCanvas.height = frameRect.height;
      const tempCtx = tempCanvas.getContext('2d');
      tempCtx.drawImage(
        canvas,
        frameRect.x, frameRect.y, frameRect.width, frameRect.height,
        0, 0, frameRect.width, frameRect.height
      );

      const imageDataUrl = tempCanvas.toDataURL('image/jpeg');
      finalImageDataUrl = imageDataUrl;
      const base64ImageData = imageDataUrl.split(',')[1];

      try {
        const response = await fetch('/api/analyze', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ base64: base64ImageData })
        });
        if (!response.ok) throw new Error('Erreur API');
        const result = await response.json();

        const aiText = result?.candidates?.[0]?.content?.parts?.[0]?.text || '';
        let cleaned = aiText.replace(/```json/gi,'').replace(/```/g,'').trim();
        let desc = "Description non disponible.";
        let prix = "Prix non disponible.";

        try {
          const obj = JSON.parse(cleaned);
          desc = obj.description || desc;
          prix = obj.prix || obj.price || prix;
        } catch { cleaned && (desc = cleaned); }

        aiDescriptionContainer.textContent = `"${desc}"`;
        aiPriceContainer.textContent = `Prix suggéré : ${prix}`;
      } catch (e) {
        console.error(e);
        aiDescriptionContainer.textContent = "Une erreur est survenue. Veuillez réessayer.";
        aiPriceContainer.textContent = "";
      } finally {
        currentAppState = AppState.DONE;
        updateUI();
      }
    }

    function resetApp() {
      currentAppState = AppState.SCANNING;
      aiDescriptionContainer.textContent = '';
      aiPriceContainer.textContent = '';
      finalImageDataUrl = null;
      startRenderLoop();
      feedback.textContent = hasHardwareZoom
        ? "Pince ou utilise le slider pour zoomer (zoom natif)."
        : "Pince ou utilise le slider pour zoomer (zoom logiciel).";
    }

    confirmButton.addEventListener('click', async () => {
      if (currentAppState === AppState.CONFIRMING) {
        currentAppState = AppState.GENERATING;
        updateUI();
        await generateDescription();
      }
    });

    retakeButton.addEventListener('click', () => {
      if (currentAppState === AppState.CONFIRMING) {
        currentAppState = AppState.SCANNING;
        startRenderLoop();
        updateUI();
      }
    });

    downloadButton.addEventListener('click', () => {
      if (!finalImageDataUrl) return;
      const link = document.createElement('a');
      link.href = finalImageDataUrl;
      link.download = 'snap-avec-novsuity.jpg';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    });

    mainButton.addEventListener('click', handleMainButtonClick);
    window.addEventListener('resize', () => { if (video.srcObject) setCanvasDimensions(); });
  </script>
</body>
</html>
