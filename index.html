<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Snap avec NovSuity</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
  <style>
    body{
      background:#111827;color:#F9FAFB;font-family:'Inter',sans-serif;
      display:flex;justify-content:center;align-items:center;min-height:100vh;margin:0;overflow:auto;
    }
    #cameraCanvas{
      max-width:100%;max-height:60vh;border-radius:.75rem;
      box-shadow:0 10px 15px -3px rgba(0,0,0,.1),0 4px 6px -2px rgba(0,0,0,.05);
    }
    #videoFeed{display:none;}

    /* ✅ NE PAS TOUCHER : tes pointillés */
    #framingGuide{
      position:absolute;top:0;left:0;border:6px dashed rgba(255,255,255,.9);
      border-radius:.75rem;pointer-events:none;box-sizing:border-box;
    }

    /* Slider simple, sans chiffres */
    input[type="range"]{-webkit-appearance:none;appearance:none;height:6px;background:#374151;border-radius:9999px;outline:none}
    input[type="range"]::-webkit-slider-thumb{-webkit-appearance:none;width:22px;height:22px;border-radius:50%;background:#06b6d4;border:2px solid #0e7490;box-shadow:0 2px 6px rgba(0,0,0,.25)}
    input[type="range"]::-moz-range-thumb{width:22px;height:22px;border-radius:50%;background:#06b6d4;border:2px solid #0e7490;box-shadow:0 2px 6px rgba(0,0,0,.25)}

    /* FLASH & COUNTDOWN (ajout) */
    #flash{
      position:fixed;inset:0;background:#fff;opacity:0;pointer-events:none;
      transition:opacity .22s ease-out;z-index:50;
    }
    #countdown{
      position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);
      font-size:6rem;font-weight:800;color:#06b6d4;opacity:0;z-index:51;
      user-select:none;transition:opacity .25s ease;
      text-shadow:0 6px 20px rgba(0,0,0,.35);
    }
  </style>
</head>
<body class="bg-gray-900 text-gray-100 flex flex-col justify-center items-center p-4">

  <!-- Ajouts UI -->
  <div id="flash"></div>
  <div id="countdown"></div>

  <div class="w-full max-w-2xl text-center">
    <h1 class="text-3xl md:text-4xl font-bold mb-2">Snap avec NovSuity</h1>
    <p id="feedback" class="text-lg text-cyan-400 mb-4 h-8">Initialisation de la caméra...</p>

    <div class="relative w-full">
      <canvas id="cameraCanvas" class="bg-gray-800 rounded-xl shadow-lg w-full"></canvas>
      <div id="framingGuide"></div>
    </div>

    <video id="videoFeed" playsinline></video>

    <!-- Slider de zoom (sans texte ni pourcentage) -->
    <div id="zoomContainer" class="mt-3 w-full max-w-lg" style="display:none;">
      <input id="zoomRange" type="range" min="1" max="3" step="0.01" value="1" class="w-full">
    </div>

    <!-- Sortie IA -->
    <div id="aiOutputContainer" class="mt-4 text-left p-4 bg-gray-800 rounded-lg" style="display:none;">
      <p id="aiDescription" class="text-lg text-gray-300 italic"></p>
      <p id="aiPriceSuggestion" class="mt-3 text-lg text-cyan-400 font-semibold"></p>
    </div>

    <!-- ✅ Conteneur d’actions flexible: pas de chevauchement sur mobile -->
    <div id="actionsContainer" class="mt-6 flex flex-wrap gap-4 justify-center">
      <button id="mainButton"
        class="w-full sm:w-auto px-8 py-3 bg-cyan-600 text-white font-semibold rounded-lg shadow-md hover:bg-cyan-700 focus:outline-none focus:ring-2 focus:ring-cyan-500 focus:ring-opacity-75 transition-transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed">
        Valider
      </button>

      <!-- visible uniquement en CONFIRMING -->
      <div id="confirmContainer" class="hidden flex flex-wrap gap-4 justify-center">
        <button id="retakeButton"
          class="w-full sm:w-auto px-6 py-2 bg-gray-600 text-white font-semibold rounded-lg shadow-md hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 transition-transform hover:scale-105">
          Reprendre
        </button>
        <button id="confirmButton"
          class="w-full sm:w-auto px-6 py-2 bg-cyan-600 text-white font-semibold rounded-lg shadow-md hover:bg-cyan-700 focus:outline-none focus:ring-2 focus:ring-cyan-500 transition-transform hover:scale-105">
          Confirmer
        </button>
      </div>

      <!-- visible uniquement en DONE -->
      <button id="downloadButton"
        class="hidden w-full sm:w-auto px-8 py-3 bg-green-600 text-white font-semibold rounded-lg shadow-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 transition-transform hover:scale-105">
        Télécharger la Photo
      </button>
    </div>
  </div>

  <script>
    const video = document.getElementById('videoFeed');
    const canvas = document.getElementById('cameraCanvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    const feedback = document.getElementById('feedback');
    const mainButton = document.getElementById('mainButton');
    const confirmContainer = document.getElementById('confirmContainer');
    const retakeButton = document.getElementById('retakeButton');
    const confirmButton = document.getElementById('confirmButton');
    const aiOutputContainer = document.getElementById('aiOutputContainer');
    const aiDescriptionContainer = document.getElementById('aiDescription');
    const aiPriceContainer = document.getElementById('aiPriceSuggestion');
    const downloadButton = document.getElementById('downloadButton');
    const framingGuideElement = document.getElementById('framingGuide');
    const zoomContainer = document.getElementById('zoomContainer');
    const zoomRange = document.getElementById('zoomRange');
    const flash = document.getElementById('flash');          // NEW
    const countdown = document.getElementById('countdown');  // NEW

    let finalImageDataUrl = null;
    let zoom = 1;
    const ZOOM_MIN = 1, ZOOM_MAX = 3;

    const AppState = { SCANNING:'scanning', CONFIRMING:'confirming', GENERATING:'generating', DONE:'done' };
    let currentAppState = AppState.SCANNING;

    async function setupCamera() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: { ideal:'environment' } } });
        video.srcObject = stream;
        video.onloadedmetadata = () => {
          video.play();
          setCanvasDimensions();
          zoomContainer.style.display = 'block';
          requestAnimationFrame(renderLoop);
        };
      } catch (e) {
        console.error("Erreur caméra:", e);
        feedback.textContent = "Impossible d'accéder à la caméra.";
        mainButton.disabled = true;
      }
    }

    function setCanvasDimensions() {
      if (!video.videoWidth) return;
      const aspect = video.videoWidth / video.videoHeight;
      const containerW = canvas.parentElement.offsetWidth;
      const maxH = window.innerHeight * 0.6;
      let w = containerW, h = w / aspect;
      if (h > maxH) { h = maxH; w = h * aspect; }
      canvas.width = Math.round(w);
      canvas.height = Math.round(h);
      updateFramingGuidePosition();
    }

    function renderLoop() {
      if (currentAppState === AppState.SCANNING) {
        if (video.videoWidth && video.videoHeight) {
          const vW = video.videoWidth, vH = video.videoHeight;
          const srcW = vW / zoom, srcH = vH / zoom;
          const sx = (vW - srcW) / 2, sy = (vH - srcH) / 2;
          ctx.drawImage(video, sx, sy, srcW, srcH, 0, 0, canvas.width, canvas.height);
        } else {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
        updateFramingGuidePosition();
      }
      updateUI();
      requestAnimationFrame(renderLoop);
    }

    function updateUI() {
      aiOutputContainer.style.display = (currentAppState === AppState.GENERATING || currentAppState === AppState.DONE) ? 'block' : 'none';
      mainButton.style.display = (currentAppState === AppState.SCANNING || currentAppState === AppState.DONE) ? 'inline-block' : 'none';
      confirmContainer.style.display = currentAppState === AppState.CONFIRMING ? 'flex' : 'none';
      downloadButton.style.display = (currentAppState === AppState.DONE) ? 'inline-block' : 'none';
      framingGuideElement.style.display = (currentAppState === AppState.SCANNING) ? 'block' : 'none';
      zoomContainer.style.display = (currentAppState === AppState.SCANNING) ? 'block' : 'none';

      switch (currentAppState) {
        case AppState.SCANNING:
          feedback.textContent = "Centrez le cadre et validez.";
          mainButton.textContent = "Valider";
          mainButton.disabled = false;
          break;
        case AppState.CONFIRMING:
          feedback.textContent = "Validez-vous cette photo ?";
          break;
        case AppState.GENERATING:
          feedback.textContent = "✨ Analyse par l'IA en cours...";
          break;
        case AppState.DONE:
          feedback.textContent = "Description générée !";
          mainButton.textContent = "Recommencer";
          mainButton.disabled = false;
          break;
      }
    }

    // --- Géométrie du cadre (inchangé visuellement) ---
    function getFrameRect() {
      const portrait = canvas.height > canvas.width;
      const widthFactor  = portrait ? 0.70 : 0.55;
      const heightFactor = 0.80;
      const w = canvas.width  * widthFactor;
      const h = canvas.height * heightFactor;
      return { width: w, height: h, x: (canvas.width - w)/2, y: (canvas.height - h)/2 };
    }
    function updateFramingGuidePosition() {
      const frame = getFrameRect();
      const bbox = canvas.getBoundingClientRect();
      const sx = bbox.width / canvas.width;
      const sy = bbox.height / canvas.height;

      const cssW = Math.round(frame.width  * sx);
      const cssH = Math.round(frame.height * sy);
      const cssX = Math.round(frame.x      * sx);
      const cssY = Math.round(frame.y      * sy);

      const el = framingGuideElement;
      el.style.width  = cssW + 'px';
      el.style.height = cssH + 'px';
      el.style.left   = cssX + 'px';
      el.style.top    = cssY + 'px';

      const stroke = Math.max(4, Math.round(Math.min(cssW, cssH) * 0.015));
      el.style.borderWidth = stroke + 'px';
      el.style.borderRadius = Math.round(stroke * 2) + 'px';
    }

    // --- Helper : cadre DOM -> coordonnées *canvas* px
    function getFrameRectInCanvasPx() {
      const frameBox  = framingGuideElement.getBoundingClientRect();
      const canvasBox = canvas.getBoundingClientRect();
      const fx = frameBox.left - canvasBox.left;
      const fy = frameBox.top  - canvasBox.top;
      const fw = frameBox.width;
      const fh = frameBox.height;
      const sx = canvas.width  / canvasBox.width;
      const sy = canvas.height / canvasBox.height;
      return {
        x: Math.round(fx * sx),
        y: Math.round(fy * sy),
        width:  Math.round(fw * sx),
        height: Math.round(fh * sy),
      };
    }

    // --- Compte à rebours + flash (ajout) ---
    function startCountdown() {
      return new Promise(resolve=>{
        let n = 3;
        countdown.style.opacity = '1';
        countdown.textContent = n;
        const timer = setInterval(()=>{
          n--;
          if (n>0) {
            countdown.textContent = n;
          } else {
            clearInterval(timer);
            countdown.style.opacity = '0';
            // petit délai pour laisser disparaître le chiffre
            setTimeout(resolve, 200);
          }
        }, 800);
      });
    }
    function doFlash() {
      flash.style.opacity = '1';
      setTimeout(()=>{ flash.style.opacity = '0'; }, 160);
    }

    // --- Capture stricte (compatible zoom) + countdown/flash
    async function handleMainButtonClick() {
      if (currentAppState !== AppState.SCANNING) return;

      // 1) Compte à rebours, 2) Flash, 3) Crop
      await startCountdown();
      doFlash();

      currentAppState = AppState.CONFIRMING;

      const frame = getFrameRectInCanvasPx();

      // zone source affichée selon zoom
      const vW = video.videoWidth, vH = video.videoHeight;
      const srcW = vW / zoom,     srcH = vH / zoom;
      const sx = (vW - srcW) / 2, sy = (vH - srcH) / 2;

      // conversion cadre(canvas) -> source(video)
      const cropX = sx + (frame.x      / canvas.width)  * srcW;
      const cropY = sy + (frame.y      / canvas.height) * srcH;
      const cropW =      (frame.width  / canvas.width)  * srcW;
      const cropH =      (frame.height / canvas.height) * srcH;

      // sortie recadrée exactement à la taille du cadre
      const out = document.createElement('canvas');
      out.width  = Math.max(1, frame.width);
      out.height = Math.max(1, frame.height);
      const octx = out.getContext('2d');
      octx.imageSmoothingEnabled = true;
      octx.drawImage(video, cropX, cropY, cropW, cropH, 0, 0, out.width, out.height);

      // afficher l'image recadrée
      canvas.width = out.width;
      canvas.height = out.height;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(out, 0, 0);

      // masquer le cadre pendant la confirmation
      framingGuideElement.style.display = 'none';
      updateUI();
    }

    // Slider + pinch
    function clamp(v,min,max){ return Math.min(max, Math.max(min, v)); }
    zoomRange.addEventListener('input', () => { zoom = clamp(Number(zoomRange.value), ZOOM_MIN, ZOOM_MAX); });
    let pinchStartDist=null, pinchStartZoom=null;
    function dist(a,b){ return Math.hypot(a.pageX-b.pageX, a.pageY-b.pageY); }
    canvas.addEventListener('touchstart',e=>{ if(e.touches.length===2){ e.preventDefault(); pinchStartDist=dist(e.touches[0],e.touches[1]); pinchStartZoom=zoom; } },{passive:false});
    canvas.addEventListener('touchmove',e=>{ if(e.touches.length===2&&pinchStartDist){ e.preventDefault(); const f=dist(e.touches[0],e.touches[1])/pinchStartDist; zoom=clamp(pinchStartZoom*f,ZOOM_MIN,ZOOM_MAX); zoomRange.value=String(zoom);} },{passive:false});
    canvas.addEventListener('touchend',e=>{ if(e.touches.length<2) pinchStartDist=null; });

    // (IA inchangé) — génère finalImageDataUrl puis passe à DONE
    async function generateDescription() {
      const dataUrl = canvas.toDataURL('image/jpeg'); // après recadrage, tout le canvas = cadre
      finalImageDataUrl = dataUrl;
      // ... ton appel IA si besoin ...
      currentAppState = AppState.DONE;
      updateUI();
    }

    function resetApp() {
      currentAppState = AppState.SCANNING;
      aiDescriptionContainer.textContent = '';
      aiPriceContainer.textContent = '';
      finalImageDataUrl = null;
      setCanvasDimensions();
      requestAnimationFrame(renderLoop);
    }

    confirmButton.addEventListener('click', async () => {
      if (currentAppState === AppState.CONFIRMING) {
        currentAppState = AppState.GENERATING;
        await generateDescription();
      }
    });
    retakeButton.addEventListener('click', () => { if (currentAppState === AppState.CONFIRMING) resetApp(); });
    downloadButton.addEventListener('click', () => {
      const url = finalImageDataUrl || canvas.toDataURL('image/jpeg');
      const a = document.createElement('a'); a.href = url; a.download = 'snap-avec-novsuity.jpg';
      document.body.appendChild(a); a.click(); a.remove();
    });

    mainButton.addEventListener('click', handleMainButtonClick);
    window.addEventListener('resize', () => { if (video.srcObject) setCanvasDimensions(); });
    window.addEventListener('load', setupCamera);
  </script>
</body>
</html>
